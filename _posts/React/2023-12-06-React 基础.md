---
layout:     post
title:      React 基础
subtitle:  
date:       2023-12-06
author:     
header-img: 
catalog: true
tags:
    - React
typora-root-url: ..
---

React，对于熟悉 Vue 的我来说并不难理解，但是有时候会感觉到新奇，有时候会感觉反人类。以下是总结，内容基本上摘自于[官网](https://react.docschina.org/)。

## 前置内容

### jsx 语法

JSX 和 React 是独立的。JSX 是一种语法扩展，而 React 是一个 JavaScript 库。

- jsx 结构中只能有一个根元素，如果你不想在标签中增加一个额外的 `<div>`，可以用 `<>` 和 `</>` 元素来代替
- jsx 结构通常会包裹一个(), 将整个 jsx 当做一个整体, 实现换行
- jsx 可以是单标签, 也可以双标签, 但是单标签必须以 /> 结尾（`<img>` => `<img/>`）
- 注释写法：{ /* JSX的注释写法 */ }
- 使用驼峰命名法给大部分属性命名，变量名称不能包含 class 这样的保留字。可以使用[转换器](https://transform.tools/html-to-jsx)将 HTML 和 SVG 标签转换成 JSX。
- 大括号内引用 JavaScript 变量，双大括号传递对象或者是 CSS ( 内联 style 属性使用驼峰命名法编写)

```
const app = (
  <div>
    <div>
      { /* JSX的注释写法 */ }
      <h2 className="message">{message}</h2>
      <br/>
    </div>
    <div style={{color: 'pink', backgroundColor: 'black'}}>哈哈哈</div>
  </div>
)
```

### 基本语法

首先大致看一下 React 组件写法以及如何挂载

```
import { createRoot } from 'react-dom/client'

function InfoList() {
  function handleClick = () => {
    alert('click card!')
  }
  
  return (
  	<div id="root">
  		<InfoCard name="taylor" sex="women" handleClick={handleClick}/>
    	<InfoCard name="blob" sex="man" handleClick={handleClick}/>
  	</div>
  )
}

function InfoCard({name, sex, handleClick=()=>{}}) {
  return (
    <section onClick={handleClick}>
      <div>
        <span className="username">姓名</span>
        <span>{name}</span>
      </div>
      <div>
        <span className="username">性别</span>
        <span>{sex}</span>
      </div>
    <section/>
  )
}

const root = createRoot(document.getElementById('root'))
root.render(<InfoList />)
```

从以上可以看出：

- React 组件就是常规的 js 函数，但是**组件的名称必须以大写字母开头**！
- React 组件需要 Return 一个 jsx，返回语句可以写在一行上，否则必须包裹在一对括号中。（没有括号包裹，任何在 return 下一行的代码都会被忽略）
- 声明 props 时，记得解构哦。prop 也可以指定默认值。（反正跟函数用法是一样的）
  - Props 是只读的时间快照：每次渲染都会收到新版本的 props。
  - 像 `<Card><Avatar /></Card>` 这样的嵌套 JSX，将被视为 `Card` 组件的 `children` prop

#### 条件渲染

使用 if... else，三目运算符（? :），与运算符（&&）来控制 dom 渲染。

> **切勿将数字放在 `&&` 左侧.**
>
> JavaScript 会自动将左侧的值转换成布尔类型以判断条件成立与否。然而，如果左侧是 `0`，整个表达式将变成左侧的值（`0`），React 此时则会渲染 `0` 而不是不进行渲染
>
> 例如，一个常见的错误是 `messageCount && <p>New messages</p>`。其原本是想当 `messageCount` 为 0 的时候不进行渲染，但实际上却渲染了 `0`。
>
> 为了更正，可以将左侧的值改成布尔类型：`messageCount > 0 && <p>New messages</p>`

#### 列表渲染

在 React 中，通常使用 map 或 filter 来渲染一个组件列表。直接放在 `map()` 方法里的 JSX 元素一般都需要指定 `key` 值！这些 key 会告诉 React，每个组件对应着数组里的哪一项，所以 React 可以把它们匹配起来。这在数组项进行移动（例如排序）、插入或删除等操作时非常重要。一个合适的 `key` 可以帮助 React 推断发生了什么，从而得以正确地更新 DOM 树。

```
const people = [
  '凯瑟琳·约翰逊: 数学家',
  '马里奥·莫利纳: 化学家',
  '穆罕默德·阿卜杜勒·萨拉姆: 物理学家',
  '珀西·莱温·朱利亚: 化学家',
  '苏布拉马尼扬·钱德拉塞卡: 天体物理学家',
];

const listItems = people.map((person, index) => <li key={index}>{person}</li>); // 不建议，最好使用 id
return <ul>{listItems}</ul>;
```

Fragment 语法的简写形式 `<> </>` 无法接受 key 值，所以你只能要么把生成的节点用一个 `<div>` 标签包裹起来，要么使用长一点但更明确的 `<Fragment>` 写法：

```
import { Fragment } from 'react';

// ...

const listItems = people.map(person =>
  <Fragment key={person.id}>
    <h1>{person.name}</h1>
    <p>{person.bio}</p>
  </Fragment>
);
```



### 状态

对于组件的状态，vue 更改数据的时候会默认改变试图。对于 React，有些奇怪，请看下面代码。

```
export default function Button() {
  let index = 0
  
  function handleClick() {
    index = index + 1
  }
  
  return (
    <button onClick={handleClick}>点击{index}次</button>
  )
}
```

点击 button，不会使得 index + 1！！！

`handleClick()` 事件处理函数正在更新局部变量 `index`。但存在两个原因使得变化不可见：

1. **局部变量无法在多次渲染中持久保存。** 当 React 再次渲染这个组件时，它会从头开始渲染——不会考虑之前对局部变量的任何更改。
2. **更改局部变量不会触发渲染。** React 没有意识到它需要使用新数据再次渲染组件。

要使用新数据更新组件，需要做两件事：

1. **保留** 渲染之间的数据。
2. **触发** React 使用新数据渲染组件（重新渲染）。

[`useState`](https://react.docschina.org/reference/react/useState) Hook 提供了这两个功能：

1. **State 变量** 用于保存渲染间的数据。
2. **State setter 函数** 更新变量并触发 React 再次渲染组件。

将以上代码替换成下面代码即可正常执行。

```
import { useState } from 'React'

export default function Button() {
  const [index, setIndex] = useState(0)
  
  function handleClick() {
    setIndex(index + 1)
  }
  
  return (
    <button onClick={handleClick}>点击{index}次</button>
  )
}
```

State 是组件私有的。如果你在两个地方渲染它，则每个副本都有独属于自己的 state。

