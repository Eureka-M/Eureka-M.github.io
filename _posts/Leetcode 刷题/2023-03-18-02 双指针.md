---
layout:     post
title:      Leetcode 刷题之双指针
subtitle:  
date:       2023-03-18
author:     
header-img: 
catalog: true
tags:
  - Leetcode 刷题
typora-root-url: ..
---

### 有序数组的 Two Sum

[leetcode 167](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/)

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。

以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

```
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(numbers, target) {
    let start = 0
    let end = numbers.length - 1
    while (start < end) {
        let sum = numbers[start] + numbers[end]
        if (sum == target) {
           return [start + 1, end + 1]
        } else if (sum < target) {
            start++
        } else {
            end--
        }
    }
    return [-1, -1]
};
```

### 两数平方和

[Leetcode 633](https://leetcode.cn/problems/sum-of-square-numbers/description/)

给定一个非负整数 `c` ，你要判断是否存在两个整数 `a` 和 `b`，使得 `a2 + b2 = c` 。

```
/**
 * @param {number} c
 * @return {boolean}
 */
var judgeSquareSum = function(c) {
    let start = 0
    let end = Math.ceil(Math.sqrt(c))
    while (start <= end) {
        let sum = start * start + end * end
        if (sum == c) {
            return true
        }
        else if (sum < c) {
            start++
        }
        else {
            end--
        }
    }
    return false
};
```

### 反转字符串的元音字符

[Leetcode 345](https://leetcode.cn/problems/reverse-vowels-of-a-string/description/)

给你一个字符串 `s` ，仅反转字符串中的所有元音字母，并返回结果字符串。(题解中得知：反转的意思是，从头尾出发，两边都遇到元音字母就对调。[汗])

元音字母包括 `'a'`、`'e'`、`'i'`、`'o'`、`'u'`，且可能以大小写两种形式出现不止一次。

```
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function(s) {
    let vowelArrs = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']

    let sArr = s.split('')
    let start = 0
    let end = sArr.length - 1
    
    while(start < end) {
        // start end 指针都指向 元音字母，交换
        let isStartVowel = vowelArrs.indexOf(sArr[start]) !== -1 
        let isEndVowel = vowelArrs.indexOf(sArr[end]) !== -1
        if (isStartVowel && isEndVowel) {
            [sArr[start], sArr[end]] = [sArr[end], sArr[start]]
            start++
            end--
        } else if (isStartVowel && !isEndVowel) {
            end--
        } else if (!isStartVowel && isEndVowel) {
            start++
        } else {
            start++
            end--
        }
    }
    return sArr.join('')
};
```

### 回文字符串

[Leetcode 680](https://leetcode.cn/problems/valid-palindrome-ii/description/)

给你一个字符串 `s`，**最多** 可以从中删除一个字符。

请你判断 `s` 是否能成为回文字符串：如果能，返回 `true` ；否则，返回 `false` 。

```
/**
 * @param {string} s
 * @return {boolean}
 */
var validPalindrome = function(s) {
    let start = 0
    let end = s.length - 1

    while(start < end) {
        if (s[start] == s[end]) {
            start++
            end--
        } else {
            // let cutStartStr = s.substring(0, start) + s.substring(start + 1, s.length) 
            // let cutEndStr = s.substring(0, end) + s.substring(end + 1, s.length) 
            // 优化: 不用计算已经遍历的部分
            let cutStartStr = s.substring(start, end)
            let cutEndStr = s.substring(start + 1, end + 1) 
            if (isPalindrome(cutStartStr) || isPalindrome(cutEndStr)) {
                return true
            } else {
                return false
            }
        }
    }
    return true
};


var isPalindrome = function(s) {
    let start = 0
    let end = s.length - 1
    while(start < end) {
        if (s[start] == s[end]) {
            start++
            end--
        } else {
            return false
        }
    }
    return true
}
```

