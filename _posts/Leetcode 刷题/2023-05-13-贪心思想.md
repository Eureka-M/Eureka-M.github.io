---
layout:     post
title:      Leetcode 刷题之贪心思想
subtitle:  
date:       2023-05-13
author:     
header-img: 
catalog: true
tags:
  - Leetcode 刷题
typora-root-url: ..
---

### 分发饼干

[leetcode 455](https://leetcode.cn/problems/assign-cookies/description/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

```
/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function(g, s) {
    let result = 0
    let p1 = 0
    let p2 = 0

    g.sort((a, b) => a - b)
    s.sort((a, b) => a - b)

    let gLength = g.length
    let sLength = s.length

    while(p1 < gLength && p2 < sLength) {
        if (s[p2] >= g[p1]) {
            result++
            p1++
            p2++
        } else {
            p2++
        }
    }
 

    return result
};
```

### 无重叠区间

[leetcode 435](https://leetcode.cn/problems/non-overlapping-intervals/description/)

给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。

```
/**
 * @param {number[][]} intervals
 * @return {number}
 */
var eraseOverlapIntervals = function(intervals) {
    let sortByFirst = intervals.sort((a, b) => {
        if (a[0] == b[0]) {
            return a[1] - b[1]
        }
        return a[0] - b[0]
    })

    let p1 = 0
    let p2 = 1
    let result = 0

    while (p2 < sortByFirst.length) {
        if (sortByFirst[p1][1] > sortByFirst[p2][0]) {
            // 重叠 比较右区间，大就移除
            if (sortByFirst[p1][1] < sortByFirst[p2][1]) {
                [sortByFirst[p1], sortByFirst[p2]] = [sortByFirst[p2], sortByFirst[p1]]
            }
            result++
        }
        p1++
        p2++
    }

    return result
};
```
