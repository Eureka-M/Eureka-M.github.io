---
layout:     post
title:      V8执行代码的过程
subtitle:  
date:       2023-02-26
author:     
header-img: 
catalog: true
tags:
  - 浏览器工作原理
typora-root-url: ..



---

# V8执行代码的过程

### 编译器

编译型语言在程序执行之前，需要经过编译器的编译，编译成二进制文件。

### 解释器

解释型语言在每次运行时都要通过解释器对程序进行动态的解释和执行。

<img src="/../img/postImage/image-20230226194901265.png" alt="image-20230226194901265" style="zoom:67%;" />

不同的是，解释器的解释过程不需要生成二进制文件，而是基于 AST 生成字节码，最后再根据字节码来执行程序、输出结果。

### 抽象语法树 AST

```
var myName = " 极客时间 "
function foo(){
 	return 23;
}
```

<img src="/../img/postImage/image-20230226195746852.png" alt="image-20230226195746852" style="zoom: 33%;" />

如何生成抽象语法树？

1. **分词**（**tokenize**），**词法分析**，将一行行的源码拆解成一个个**token**，**token指语法上不能再分的单个字符/字符串**。

<img src="/../img/postImage/image-20230226200214631.png" alt="image-20230226200214631" style="zoom: 50%;" />

2. 解析（parse），语法分析，将上一步生成的 token，根据语法规则转为 AST。

### 字节码

刚开始 V8 并没有字节码，而是将 AST 转换成机器码。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器。

**字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。**

![image-20230226202350876](/../img/postImage/image-20230226202350876.png)

可以看出，机器码所占用的空间远远超过字节码。

### V8生成可执行代码过程

下面是过程图：

<img src="/../img/postImage/image-20230226195455416.png" alt="image-20230226195455416" style="zoom:67%;" />

1. 生成抽象语法树 AST 和执行上下文

2. 生成字节码，解释器 Ignition 根据 AST 生成字节码，并解释执行字节码。

3. 执行代码。

    通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。

    在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。

    字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为**即时编译（JIT）**。

    具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。

    <img src="/../img/postImage/image-20230226202707265.png" alt="image-20230226202707265" style="zoom:50%;" />