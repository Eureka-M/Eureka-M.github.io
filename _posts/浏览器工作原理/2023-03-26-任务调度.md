---
layout:     post
title:      任务调度
subtitle:  
date:       2023-03-26
author:     
header-img: 
catalog: true
tags:
  - 浏览器工作原理
typora-root-url: ..
---

### 单消息队列

当产生了新的任务，渲染进程将其添加到消息队列尾部，在执行任务过程中，渲染进程会顺序地从消息队列头部取出任务并执行。

**问题？**

**在单消息队列架构下，存在着低优先级任务会阻塞高优先级任务的情况。像极了 HTTP 协议的队头阻塞问题，那么我们也把这个问题称为消息队列的队头阻塞问题**

在基于这种单消息队列的架构下，如果用户发出一个点击事件或者缩放页面的事件，而在此时，该任务前面可能还有很多不太重要的任务在排队等待着被执行，诸如 V8 的垃圾回收、DOM 定时器等任务，如果执行这些任务需要花费的时间过久的话，那么就会让用户产生卡顿的感觉。

### Chrome解决对头阻塞问题

#### SETP1：引入一个高优先级队列

在交互阶段，下列任务被视为高优先级任务，如：

通过鼠标出发的点击任务、滚动页面任务；通过手势触发的页面缩放；通过 CSS、Javascript 等操作触发的动画特效等任务。

不言而喻，高优先级队列会被优先执行。如何执行呢？

在渲染进程中引入一个`任务调度器`，负责从多个消息队列中选出合适的任务，通常实现的逻辑，先按照顺序从`高优先级队列`中取出任务，如果高优先级的队列为空，那么再按照顺序从`低优级队列`中取出任务。

但是，如果将用户输入的消息或者合成消息添加进多个不同优先级的队列中，那么这种任务的相对执行顺序就会被打乱，甚至有可能出现还未处理输入事件，就合成了该事件要显示的图片。因此我们需要让一些相同类型的任务保持其相对执行顺序。

#### SETP2：根据消息类型来实现消息队列

为解决上述问题，chrome 将不同类型的任务创建不同优先级的消息队列。如：

可以创建输入事件的消息队列，用来存放输入事件。
可以创建合成任务的消息队列，用来存放合成事件。
可以创建默认消息队列，用来保存如资源加载的事件和定时器回调等事件。

还可以创建一个空闲消息队列，用来存放 V8 的垃圾自动垃圾回收这一类实时性不高的事件。

这种策略已经相当实用了，但是它依然存在着问题，那就是这几种消息队列的优先级都是固定的，任务调度器会按照这种固定好的`静态的优先级`来分别调度任务。**在页面加载阶段，如果依然要优先执行用户输入事件和合成事件，那么页面的解析速度将会被拖慢。**

#### SETP3：动态调度策略

下图展示了 Chromium 在不同的阶段下，是如何调整消息队列优先级的

<img src="/../img/postImage/image-20230326224009876.png" alt="image-20230326224009876" style="zoom:50%;" />

**页面加载阶段**

至于交互和合成并不是这个阶段的核心诉求，所以，在加载阶段将页面解析，JavaScript 脚本执行等任务调整为优先级最高的队列，降低交互合成这些队列的优先级。

**交互阶段**

当渲染进程接收到用户交互的任务后，接下来大概率是要进行绘制合成操作，因此我们可以设置，**当在执行用户交互的任务时，将合成任务的优先级调整到最高**。

**空闲阶段**

接下来，处理完成 DOM，计算好布局和绘制，就需要将信息提交给合成线程来合成最终图片了，然后合成线程进入工作状态。现在的场景是合成线程在工作了，那么我们就可以**把下个合成任务的优先级调整为最低，并将页面解析、定时器等任务优先级提升**。

在合成完成之后，合成线程会提交给渲染主线程提交完成合成的消息，如果当前合成操作执行的非常快，比如从用户发出消息到完成合成操作只花了 8 毫秒，而屏幕刷新是 16.66（1/60）毫秒，这个刷新周期内不需要再更新页面了。就可以执行一些不太紧急的任务，如垃圾回收等等。

#### SETP4：任务饿死

以上方案看上去似乎非常完美了，不过依然存在一个问题，那就是**在某个状态下，一直有新的高优先级的任务加入到队列中，这样就会导致其他低优先级的任务得不到执行，这称为任务饿死。**

Chrome 为了解决任务饿死的问题，给每个队列设置了`执行权重`，也就是如果连续执行了一定个数的高优先级的任务，那么中间会执行一次低优先级的任务，这样就缓解了任务饿死的情况。

