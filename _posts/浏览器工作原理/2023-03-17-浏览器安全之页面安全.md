---
layout:     post
title:      浏览器安全之页面安全
subtitle:  
date:       2023-03-17
author:     
header-img: 
catalog: true
tags:
  - 浏览器工作原理
typora-root-url: ..
---

### 安全策略的重要性

1. 保护用户隐私和数据安全
2. 防止恶意攻击

页面中最基础、最核心的安全策略：同源策略（Same-origin policy）

### 同源策略

同源：如果两个 URL 的**协议**，**域名**，**端口**都相同，那么久称这两个 URL 同源。

浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。

同源策略主要表现在 DOM、Web 数据和网络这个三个层面。

**DOM**：同源的两个 URL 页面是可以进行 DOM 操作的，而非同源的会报错：跨域访问，无法访问上一个窗口的 DOM 内容。

**Web 数据**：同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。

**网络**：同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。

### 出“卖”的安全性

#### 页面中可以嵌入第三方资源

如果让页面上所有的 HTML 文件、JavaScript 文件、CSS 文件、图片等资源都部署在同一台服务器上，这是不太符合 Web 的初衷的。但是同样也会带来危机：

当你不小心点击了页面中的一个恶意链接时，恶意 JavaScript 代码可以读取页面数据并将其发送给服务器。这就是一个典型的 XSS 攻击。

为了解决 XSS 攻击，浏览器引入了内容安全策略，称为 CSP。**CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。**

#### 跨域资源共享和跨文档消息机制

同源策略会阻止不同源之间发起请求，而跨域资源共享（CORS）可以进行跨域访问控制，使得跨域数据传输得以安全进行。

浏览器中引入了跨文档消息机制，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。

### XSS 攻击

Cross Site Scripting，翻译过来就是“跨站脚本”。**XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。**

要想避免站点被注入恶意脚本，就要知道有哪些常见的注入方式。通常情况下，主要有**存储型 XSS 攻击**、**反射型 XSS 攻击**和**基于 DOM的 XSS 攻击**三种方式来注入恶意脚本。

#### 存储型 XSS 攻击

<img src="/../img/postImage/image-20230317214736823.png" alt="image-20230317214736823" style="zoom: 50%;" />

步骤如下：

首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；

然后用户向网站请求包含了恶意 JavaScript 脚本的页面；

当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。

#### 反射型 XSS 攻击

恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。

举个例子：页面读取 URL 上的参数并显示在页面上，如果黑客通过 QQ 群或者邮件等渠道诱导用户去点击这些恶意链接（参数上拼接了恶意脚本），这样用户就会将一段含有恶意代码的请求提交给 WEB 服务器，服务器收到请求，又将恶意代码反射给了浏览器端。

> Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型XSS 攻击不同的地方。

#### 基于 DOM 的 XSS 攻击

黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。

### 如何阻止 XSS 攻击

无论是何种类型的 XSS 攻击，它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。

所以，我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。

常用 XSS 攻击策略如下：

- 服务器对输入脚本进行过滤或转码

    ```
    code:<script>alert('你被 xss 攻击了')</script>
    // 过滤
    code:
    // 转码
    code:&lt;script&gt;alert(&#39; 你被 xss 攻击了 &#39;)&lt;/script&gt;
    ```

- 充分利用 CSP

    - 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；
    - 禁止向第三方域提交数据，这样用户数据也不会外泄；
    - 禁止执行内联脚本和未授权的脚本；
    - 提供上报机制，可以帮助尽快发现有哪些 XSS 攻击，以便尽快修复问题。

- 使用 HttpOnly 属性

    - HttpOnly 属性来保护 Cookie 的安全，服务器可以将某些 Cookie 设置为 HttpOnly 标志

### CSRF 攻击

Cross-site request forgery，所以又称为“跨站请求伪造”。**是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。**

#### 如何攻击？

自动发起 get/post 请求，引诱用户点击链接

黑客在他的站点上伪造 POST 请求，当用户打开黑客的站点时，是自动提交 POST 请求。比如说 post 转账请求，服务器执行。于是用户账户上的钱就被转移到黑客的账户上去了。

> 和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。

CSRF 的三个必要条件：

1. 目标站点一定要有 CSRF 漏洞；
2. 用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；
3. 需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛

#### 如何防止？

- Cookie 的 SameSite 属性，第三方站点发送请求时禁止 Cookie 的发送

    SameSite 选项通常有 Strict、Lax 和 None 三个值。

    - Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方Cookie。
    - Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。
    - 使用 None 的话，在任何情况下都会发送 Cookie 数据

- 服务器端验证请求来源的站点

    使用HTTP 请求头中的 Referer 和 Origin 属性。

    - Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。
    - 通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post方法发送请求时，都会带上 Origin 属性。Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。

- CSRF Token

    - 在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。

        如果是从第三方站点发出的请求，那么将无法获取到
        CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。

