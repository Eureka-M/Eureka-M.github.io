---
layout:     post
title:      垃圾数据是如何被回收的？
subtitle:  
date:       2023-02-26
author:     
header-img: 
catalog: true
tags:
  - 浏览器工作原理
typora-root-url: ..
---

# 垃圾数据是如何被回收的？

对于 Javascript 语言，产生的垃圾数据是由垃圾回收器来释放的。而数据是存储在栈和堆两种内存空间中的。

那么，垃圾回收器是如何回收的呢？

## 栈中垃圾的回收

首先看一段代码：

```
function foo(){
     var a = 1
     var b = {name:" 极客邦 "}
     function showName(){
         var c = " 极客时间 "
         var d = {name:" 极客时间 "}
     }
     showName()
}
foo()
```

执行到第6行时，调用栈和堆内存的空间状态图如下所示：

<img src="/../img/postImage/image-20230226173530875.png" alt="image-20230226173530875" style="zoom:50%;" />

当 showName 函数被执行完毕之后，showName 函数的执行上下文就会被回收掉。如何回收呢？

当在执行 showName 函数时，会有一个指针 **ESP**（**记录当前执行状态的指针**）就会指向 showName 函数的执行上下文。如下图所示：

<img src="/../img/postImage/image-20230226173743438.png" alt="image-20230226173743438" style="zoom: 50%;" />

当 showName 执行完毕之后，需要销毁掉 showName 的执行上下文。javascript 会将 ESP 下移到 foo 的执行上下文。

<img src="/../img/postImage/image-20230226174313716.png" alt="image-20230226174313716" style="zoom:50%;" />

showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。

> 当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。



## 堆中垃圾的回收

堆中的垃圾回收靠**垃圾回收器**。

V8 会把堆分成两个区：**新生代**和**老生代**。新生代存放的是生存时间短的对象。老生代存放的是生存时间比较久的对象。



### 垃圾回收器的工作流程

1. **标记空间中的活动对象和非活动对象**。活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
2. **回收非活动对象占据的内存**。
3. **内存整理**。频繁回收对象后，内存中就会存在大量不连续空间（内存碎片）。



### 副垃圾回收器

**负责新生区的垃圾回收**。大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。

新生代中用 Scavenge 算法来处理，Scavenge 算法把新生区的空间划分成两块：对象区域 以及 空闲区域。

<img src="/../img/postImage/image-20230226181718904.png" alt="image-20230226181718904" style="zoom:50%;" />

新加入的对象都会被放入对象区域，等这块空间快装满时，就会进行一次垃圾清理操作。

过程如下：

1. 对**对象区域**的垃圾进行**标记**，标记完成**进入垃圾清理**阶段

2. 副垃圾回收器将存活的对象复制进空闲区域，同时进行有序的排列

3. 复制完成后，对象区域和空间区域进行对调。

    

> 所以，副垃圾回收器回收过后不会产生内存碎片。但是复制操作需要时间成本，如果对象区域的空间比较大，清理的时间就会比较久，所以，一般新生区的空间会被设置得比较小。但是同时很容易使得该区域被装满，所以 javascript 引擎采用**对象晋升策略**，经过两次垃圾回收依然还存活的对象会被移动到老生区。



### 主垃圾回收器

负责老生区的垃圾回收。除了新生区晋升的对象，一些大的对象会直接被分配到老生区。

老生区不采用 Scavenge 算法，因为复制大的对象会花费更多的时间，所以采用的是 **标记 - 清除** （**Mark-Sweep**）算法。

过程如下：

1. **标记**：从一组根元素开始，递归遍历根元素，能到达的元素称为活动对象，**没有到达的元素**判断为**垃圾数据**。
2. **清除**：下图清除红色数据的过程：

<img src="/../img/postImage/image-20230226183302715.png" alt="image-20230226183302715" style="zoom: 50%;" />

可以看到，会产生大量不连续的内存碎片。所以产生了**标记-整理**（**Mark-Compact**）算法。

第一步仍然是标记，不过第二步，会让所有存活的对象都向一端移动，直接清理掉端边界以外的内存。如下图：

<img src="/../img/postImage/image-20230226183612087.png" alt="image-20230226183612087" style="zoom:50%;" />

## 全停顿

由于 javascript 是运行在主线程之上的，一旦进行垃圾回收算法，都需要将正在执行的 javascipt 脚本暂停下来，待垃圾回收完毕之后再恢复脚本执行。这种行为称为全停顿。

对于新生代来说，空间不大，影响不大。而对于老生代来说，影响比较大，会造成页面卡顿的现象。

为了降低因垃圾回收造成的卡断时间，v8 将标记过程分为一个个的**子标记**过程，**让垃圾回收标记和 javascript 脚本逻辑交替进行**，直到标记完成。这个算法称为**增量标记**（**Incremental Marking**）算法。

这样不会让用户因为垃圾回收任务而感受到页面的卡顿了。
